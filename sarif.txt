{"$schema":"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json","runs":[{"results":[{"level":"error","locations":[{"physicalLocation":{"artifactLocation":{"uri":"lib/basket_web/controllers/page_controller.ex"},"region":{"endColumn":13,"endLine":6,"startColumn":13,"startLine":6}}}],"message":{"text":"Misc.BinToTerm: Unsafe `binary_to_term`"},"partialFingerprints":{"primaryLocationLineHash":"A6437970CA904F1667458C3E01DCD024"},"ruleId":"SBLW014"},{"level":"error","locations":[{"physicalLocation":{"artifactLocation":{"uri":"config/prod.exs"},"region":{"endColumn":1,"endLine":1,"startColumn":1,"startLine":1}}}],"message":{"text":"Config.HTTPS: HTTPS Not Enabled"},"partialFingerprints":{"primaryLocationLineHash":"C15BCE8CAF49A8448E904E375BA0C396"},"ruleId":"SBLW009"},{"level":"error","locations":[{"physicalLocation":{"artifactLocation":{"uri":"lib/basket_web/router.ex"},"region":{"endColumn":5,"endLine":10,"startColumn":5,"startLine":10}}}],"message":{"text":"Config.CSP: Missing Content-Security-Policy"},"partialFingerprints":{"primaryLocationLineHash":"B4E75CBBD6D865903F2135D750E4B414"},"ruleId":"SBLW003"},{"level":"warning","locations":[{"physicalLocation":{"artifactLocation":{"uri":"lib/basket/goods.ex"},"region":{"endColumn":25,"endLine":43,"startColumn":25,"startLine":43}}}],"message":{"text":"SQL.Query: SQL injection"},"partialFingerprints":{"primaryLocationLineHash":"839FE72A8BBF22513C97CAC9E9D31F5C"},"ruleId":"SBLW017"},{"level":"warning","locations":[{"physicalLocation":{"artifactLocation":{"uri":"lib/basket/goods.ex"},"region":{"endColumn":25,"endLine":58,"startColumn":25,"startLine":58}}}],"message":{"text":"SQL.Query: SQL injection"},"partialFingerprints":{"primaryLocationLineHash":"F4D16D9F4071D02ECA0BDCBD870A5316"},"ruleId":"SBLW017"}],"tool":{"driver":{"informationUri":"https://sobelow.io","name":"Sobelow","rules":[{"fullDescription":{"text":"XSS in `send_resp`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a high severity finding. XSS can lead to user account compromise and a malicious worm spreading via JavaScript. See the [MySpace Samy worm](https://en.wikipedia.org/wiki/Samy_(computer_worm)) for a real world example. \n\n**How To Verify**\nIn Phoenix you can pass HTML directly to `send_resp`.\n\n\n```elixir\ndef send_resp_html(conn, %{\"i\" => i}) do\n  conn\n  |> put_resp_content_type(\"text/html\")\n  |> send_resp(200, \"#{i}\")\nend\n```\n\n\nNote that an attacker can set `i` to `<script>alert(1)</script>`. However, the above example is unlikely to be seen in real code. Consider a file upload function in a Phoenix application, where the `content-type` of the uploaded image is set by the user.\n\n\n```elixir\ndef view_photo(conn, %{\"filename\" => filename}) do\n  case ImgServer.get(filename) do\n    %{content_type: content_type, bin: bin} ->\n      conn\n      |> put_resp_content_type(content_type)\n      |> send_resp(200, bin)\n    _ ->\n      conn\n      |> put_resp_content_type(\"text/html\")\n      |> send_resp(404, \"Not Found\")\n  end\nend\n```\n\n\n`view_photo` is vulnerable to XSS, because an attacker can upload an HTML document, for example: \n\n\n`<script>alert(1)</script>`\n\n\nWith the content-type `text/html`. When a user visits the page for the uploaded file, the attacker controlled JavaScript will execute. Additional details - https://paraxial.io/blog/xss-phoenix\n\n**How To Fix**\nConsider how user input is being passed to `send_resp`. If user input can be used to build HTML elements on the page, the function is vulnerable. Use the `Phoenix.Controller.render/3` function, which is the standard way to handle user input in HTML documents in Phoenix. The `render` function is the standard pattern seen in Phoenix applications, because it protects against XSS by default. \n\n\nhttps://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3\n","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a high severity finding. XSS can lead to user account compromise and a malicious worm spreading via JavaScript. See the [MySpace Samy worm](https://en.wikipedia.org/wiki/Samy_(computer_worm)) for a real world example. \n\n**How To Verify**\nIn Phoenix you can pass HTML directly to `send_resp`.\n\n\n```elixir\ndef send_resp_html(conn, %{\"i\" => i}) do\n  conn\n  |> put_resp_content_type(\"text/html\")\n  |> send_resp(200, \"#{i}\")\nend\n```\n\n\nNote that an attacker can set `i` to `<script>alert(1)</script>`. However, the above example is unlikely to be seen in real code. Consider a file upload function in a Phoenix application, where the `content-type` of the uploaded image is set by the user.\n\n\n```elixir\ndef view_photo(conn, %{\"filename\" => filename}) do\n  case ImgServer.get(filename) do\n    %{content_type: content_type, bin: bin} ->\n      conn\n      |> put_resp_content_type(content_type)\n      |> send_resp(200, bin)\n    _ ->\n      conn\n      |> put_resp_content_type(\"text/html\")\n      |> send_resp(404, \"Not Found\")\n  end\nend\n```\n\n\n`view_photo` is vulnerable to XSS, because an attacker can upload an HTML document, for example: \n\n\n`<script>alert(1)</script>`\n\n\nWith the content-type `text/html`. When a user visits the page for the uploaded file, the attacker controlled JavaScript will execute. Additional details - https://paraxial.io/blog/xss-phoenix\n\n**How To Fix**\nConsider how user input is being passed to `send_resp`. If user input can be used to build HTML elements on the page, the function is vulnerable. Use the `Phoenix.Controller.render/3` function, which is the standard way to handle user input in HTML documents in Phoenix. The `render` function is the standard pattern seen in Phoenix applications, because it protects against XSS by default. \n\n\nhttps://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3\n"},"id":"SBLW031","name":"XSS.SendResp","properties":{"security-severity":"8.7"},"shortDescription":{"text":"XSS in `send_resp`"}},{"fullDescription":{"text":"XSS in `put_resp_content_type`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a high severity finding. XSS can lead to user account compromise and a malicious worm spreading via JavaScript. See the [MySpace Samy worm](https://en.wikipedia.org/wiki/Samy_(computer_worm)) for a real world example. \n\n**How To Verify**\n\nConsider a file upload function in a Phoenix application, where the `content-type` of the uploaded image is set by the user.\n\n\n```\ndef view_photo(conn, %{\"filename\" => filename}) do\n  case ImgServer.get(filename) do\n    %{content_type: content_type, bin: bin} ->\n      conn\n      |> put_resp_content_type(content_type)\n      |> send_resp(200, bin)\n    _ ->\n      conn\n      |> put_resp_content_type(\"text/html\")\n      |> send_resp(404, \"Not Found\")\n  end\nend\n```\n\n\n`view_photo` is vulnerable to XSS, because an attacker can upload an HTML document, for example: \n\n\n`<script>alert(1)</script>`\n\n\nWith the content-type `text/html`. When a user visits the page for the uploaded file, the attacker controlled JavaScript will execute. Additional details - https://paraxial.io/blog/xss-phoenix\n\n**How To Fix**\n\nDo not allow users to upload HTML documents, which are then shown to users. If you are implementing a file upload system, where only images are expected, do not allow `content-type` to be set by users. Restrict the allowed `content-type` values to a pre-defined list, for example `image/jpeg`, `image/png`, etc. \n","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a high severity finding. XSS can lead to user account compromise and a malicious worm spreading via JavaScript. See the [MySpace Samy worm](https://en.wikipedia.org/wiki/Samy_(computer_worm)) for a real world example. \n\n**How To Verify**\n\nConsider a file upload function in a Phoenix application, where the `content-type` of the uploaded image is set by the user.\n\n\n```\ndef view_photo(conn, %{\"filename\" => filename}) do\n  case ImgServer.get(filename) do\n    %{content_type: content_type, bin: bin} ->\n      conn\n      |> put_resp_content_type(content_type)\n      |> send_resp(200, bin)\n    _ ->\n      conn\n      |> put_resp_content_type(\"text/html\")\n      |> send_resp(404, \"Not Found\")\n  end\nend\n```\n\n\n`view_photo` is vulnerable to XSS, because an attacker can upload an HTML document, for example: \n\n\n`<script>alert(1)</script>`\n\n\nWith the content-type `text/html`. When a user visits the page for the uploaded file, the attacker controlled JavaScript will execute. Additional details - https://paraxial.io/blog/xss-phoenix\n\n**How To Fix**\n\nDo not allow users to upload HTML documents, which are then shown to users. If you are implementing a file upload system, where only images are expected, do not allow `content-type` to be set by users. Restrict the allowed `content-type` values to a pre-defined list, for example `image/jpeg`, `image/png`, etc. \n"},"id":"SBLW028","name":"XSS.ContentType","properties":{"security-severity":"8.7"},"shortDescription":{"text":"XSS in `put_resp_content_type`"}},{"fullDescription":{"text":"XSS"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. User input should not be passed to the `Phoenix.HTML.raw` function, due to the risk of XSS - https://hexdocs.pm/phoenix_html/Phoenix.HTML.html\n\n**How To Verify**\nConsider the following code:\n\n```\nlib/cross_web/templates/page/render_b.html.eex\n\n<h2>User input (vulnerable due to Phoenix.HTML.raw/1): </h2>\n<%= raw @i %>\n```\n\nThe `i` variable is controlled by user input, and is being passed to the `raw` function. Submit a request that sets `i` to `<script>alert(1)</script>`, and see how the alert box is rendered. If external user input results in JavaScript being executed, this is a true positive. If the variable passed to `raw` is not controlled by the user, this is a false positive. See [Cross Site Scripting (XSS) Patterns in Phoenix](https://paraxial.io/blog/xss-phoenix) for more details.\n\n**How To Fix**\nDo not pass user input to the `raw` function. Ideally you should avoid using `raw`, but if you must, ensure that data created at runtime from user input is not passed to `raw`. \n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. User input should not be passed to the `Phoenix.HTML.raw` function, due to the risk of XSS - https://hexdocs.pm/phoenix_html/Phoenix.HTML.html\n\n**How To Verify**\nConsider the following code:\n\n```\nlib/cross_web/templates/page/render_b.html.eex\n\n<h2>User input (vulnerable due to Phoenix.HTML.raw/1): </h2>\n<%= raw @i %>\n```\n\nThe `i` variable is controlled by user input, and is being passed to the `raw` function. Submit a request that sets `i` to `<script>alert(1)</script>`, and see how the alert box is rendered. If external user input results in JavaScript being executed, this is a true positive. If the variable passed to `raw` is not controlled by the user, this is a false positive. See [Cross Site Scripting (XSS) Patterns in Phoenix](https://paraxial.io/blog/xss-phoenix) for more details.\n\n**How To Fix**\nDo not pass user input to the `raw` function. Ideally you should avoid using `raw`, but if you must, ensure that data created at runtime from user input is not passed to `raw`. \n"},"id":"SBLW030","name":"XSS.Raw","properties":{"security-severity":"8.7"},"shortDescription":{"text":"XSS"}},{"fullDescription":{"text":"XSS in `html`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. User input should not be passed to the `Phoenix.Controller.html/2` function, due to the risk of XSS - https://hexdocs.pm/phoenix/Phoenix.Controller.html#html/2 \n\n**How To Verify**\n\nAre you passing user input to the `Phoenix.Controller.html/2` function? Consider an example Phoenix controller: \n\n\n```elixir\ndef html_resp(conn, %{\"i\" => i}) do\n  html(conn, \"<html><head>#{i}</head></html>\")\nend\n```\n\n\nThis function is vulnerable to XSS, because user input is being passed directly into the HTML document. Additional details - https://paraxial.io/blog/xss-phoenix\n\n**How To Fix**\n\nUse the `Phoenix.Controller.render/3` function, which is the standard way to handle user input in HTML documents in Phoenix. The `render` function is the standard pattern seen in Phoenix applications, because it protects against XSS by default.\n\n\nhttps://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3\n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. User input should not be passed to the `Phoenix.Controller.html/2` function, due to the risk of XSS - https://hexdocs.pm/phoenix/Phoenix.Controller.html#html/2 \n\n**How To Verify**\n\nAre you passing user input to the `Phoenix.Controller.html/2` function? Consider an example Phoenix controller: \n\n\n```elixir\ndef html_resp(conn, %{\"i\" => i}) do\n  html(conn, \"<html><head>#{i}</head></html>\")\nend\n```\n\n\nThis function is vulnerable to XSS, because user input is being passed directly into the HTML document. Additional details - https://paraxial.io/blog/xss-phoenix\n\n**How To Fix**\n\nUse the `Phoenix.Controller.render/3` function, which is the standard way to handle user input in HTML documents in Phoenix. The `render` function is the standard pattern seen in Phoenix applications, because it protects against XSS by default.\n\n\nhttps://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3\n"},"id":"SBLW029","name":"XSS.HTML","properties":{"security-severity":"8.7"},"shortDescription":{"text":"XSS in `html`"}},{"fullDescription":{"text":"SQL injection"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. User input should not be passed to the `Phoenix.Controller.html/2` function, due to the risk of XSS - https://hexdocs.pm/phoenix/Phoenix.Controller.html#html/2 \n\n**How To Verify**\n\nAre you passing user input to the `Phoenix.Controller.html/2` function? Consider an example Phoenix controller: \n\n\n```elixir\ndef html_resp(conn, %{\"i\" => i}) do\n  html(conn, \"<html><head>#{i}</head></html>\")\nend\n```\n\n\nThis function is vulnerable to XSS, because user input is being passed directly into the HTML document. Additional details - https://paraxial.io/blog/xss-phoenix\n\n**How To Fix**\n\nUse the `Phoenix.Controller.render/3` function, which is the standard way to handle user input in HTML documents in Phoenix. The `render` function is the standard pattern seen in Phoenix applications, because it protects against XSS by default.\n\n\nhttps://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3\n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. User input should not be passed to the `Phoenix.Controller.html/2` function, due to the risk of XSS - https://hexdocs.pm/phoenix/Phoenix.Controller.html#html/2 \n\n**How To Verify**\n\nAre you passing user input to the `Phoenix.Controller.html/2` function? Consider an example Phoenix controller: \n\n\n```elixir\ndef html_resp(conn, %{\"i\" => i}) do\n  html(conn, \"<html><head>#{i}</head></html>\")\nend\n```\n\n\nThis function is vulnerable to XSS, because user input is being passed directly into the HTML document. Additional details - https://paraxial.io/blog/xss-phoenix\n\n**How To Fix**\n\nUse the `Phoenix.Controller.render/3` function, which is the standard way to handle user input in HTML documents in Phoenix. The `render` function is the standard pattern seen in Phoenix applications, because it protects against XSS by default.\n\n\nhttps://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3\n"},"id":"SBLW017","name":"SQL.Query","properties":{"security-severity":"9.7"},"shortDescription":{"text":"SQL injection"}},{"fullDescription":{"text":"SQL injection"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a critical severity finding. SQL injection can be used by an attacker to run unauthorized database commands, leading to data being stolen, modified, or deleted. \n\n**How To Verify**\n\nBelow is an example of code that is vulnerable to SQL injection:\n\n\n```\n  def e_get_fruit(min_q) do\n    q = \"\"\"\n    SELECT f.id, f.name, f.quantity, f.secret\n    FROM fruits AS f\n    WHERE f.quantity > #{min_q} AND f.secret = FALSE\n    \"\"\"\n    Ecto.Adapters.SQL.stream(Repo, q)\n  end\n```\n\n\nThe key line is `WHERE f.quantity > #{min_q} AND f.secret = FALSE`, where `min_q` is user input. You should never construct an SQL query from user input. Rather, external input should be passed as a parameter to the query. For example:\n\n\n`Ecto.Adapters.SQL.stream(MyRepo, \"SELECT $1::integer + $2\", [user_in_a, user_in_b])`\n\n\nis not vulnerable, because the user input `(user_in_a, user_in_b)` is being passed as parameters to the SQL query. Additional details - https://paraxial.io/blog/sql-injection\n\n**How To Fix**\n\nEnsure that all user input is passed as a parameter to the `query` function. \n\n\nNot safe:\n`Ecto.Adapters.SQL.stream(Repo, \"SELECT * FROM potions WHERE name = #{user_input}\")`\n\n\nNot safe:\n`Ecto.Adapters.SQL.stream(Repo, \"SELECT * FROM potions WHERE name = \" <> user_input)`\n\n\nSafe:\n`Ecto.Adapters.SQL.stream(Repo, \"SELECT * FROM potions WHERE name = $1\", [user_input])`\n","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a critical severity finding. SQL injection can be used by an attacker to run unauthorized database commands, leading to data being stolen, modified, or deleted. \n\n**How To Verify**\n\nBelow is an example of code that is vulnerable to SQL injection:\n\n\n```\n  def e_get_fruit(min_q) do\n    q = \"\"\"\n    SELECT f.id, f.name, f.quantity, f.secret\n    FROM fruits AS f\n    WHERE f.quantity > #{min_q} AND f.secret = FALSE\n    \"\"\"\n    Ecto.Adapters.SQL.stream(Repo, q)\n  end\n```\n\n\nThe key line is `WHERE f.quantity > #{min_q} AND f.secret = FALSE`, where `min_q` is user input. You should never construct an SQL query from user input. Rather, external input should be passed as a parameter to the query. For example:\n\n\n`Ecto.Adapters.SQL.stream(MyRepo, \"SELECT $1::integer + $2\", [user_in_a, user_in_b])`\n\n\nis not vulnerable, because the user input `(user_in_a, user_in_b)` is being passed as parameters to the SQL query. Additional details - https://paraxial.io/blog/sql-injection\n\n**How To Fix**\n\nEnsure that all user input is passed as a parameter to the `query` function. \n\n\nNot safe:\n`Ecto.Adapters.SQL.stream(Repo, \"SELECT * FROM potions WHERE name = #{user_input}\")`\n\n\nNot safe:\n`Ecto.Adapters.SQL.stream(Repo, \"SELECT * FROM potions WHERE name = \" <> user_input)`\n\n\nSafe:\n`Ecto.Adapters.SQL.stream(Repo, \"SELECT * FROM potions WHERE name = $1\", [user_input])`\n"},"id":"SBLW018","name":"SQL.Stream","properties":{"security-severity":"9.7"},"shortDescription":{"text":"SQL injection"}},{"fullDescription":{"text":"Directory Traversal in `send_file`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. If user input is passed to `send_file`, an attacker may be able to read unauthorized files, such as `../config/prod.secrets.exs`, and make unauthorized changes to the filesystem. \n\n**How To Verify**\n\nConsider the example function in a Phoenix controller:\n\n\n```elixir\ndef user_pfp(conn, %{\"file_name\" => file_name}) do\n  send_file(conn, 200, file_name)\nend\n```\n\n\nWhen `file_name` is controlled by the user, this is a true positive. If user input is being passed to `send_file`, this is a true positive.\n\n**How To Fix**\n\nDo not pass user input to `send_file`. Inputs to `send_file` should be pre-defined in the source code, not created dynamically by user input. \n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. If user input is passed to `send_file`, an attacker may be able to read unauthorized files, such as `../config/prod.secrets.exs`, and make unauthorized changes to the filesystem. \n\n**How To Verify**\n\nConsider the example function in a Phoenix controller:\n\n\n```elixir\ndef user_pfp(conn, %{\"file_name\" => file_name}) do\n  send_file(conn, 200, file_name)\nend\n```\n\n\nWhen `file_name` is controlled by the user, this is a true positive. If user input is being passed to `send_file`, this is a true positive.\n\n**How To Fix**\n\nDo not pass user input to `send_file`. Inputs to `send_file` should be pre-defined in the source code, not created dynamically by user input. \n"},"id":"SBLW021","name":"Traversal.SendFile","properties":{"security-severity":"8.7"},"shortDescription":{"text":"Directory Traversal in `send_file`"}},{"fullDescription":{"text":"Directory Traversal in `File` function"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. If user input is passed to a `File` function, an attacker may be able to read unauthorized files, such as `../config/prod.secrets.exs`, and make unauthorized changes to the filesystem. \n\n**How To Verify**\nIs user input being sent to the `File` function? If it is, this is a true positive. \n\n**How To Fix**\nDo not pass user input to `File` functions. The input should be system generated, for example: \n\n\n`%Plug.Upload{filename: filename, path: path} = upload`\n\n\nWhen `upload` is set by the user, it is not safe to pass the `filename` variable. The `path` variable is generated by plug, for example:\n\n\n`/var/folders/0m/d5lzvxvs181cl_f5m1x3wrx40000gn/T/plug-1681/multipart-1681411044-723629749623759-3`\n\n\nand is safe to pass as a variable. ","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. If user input is passed to a `File` function, an attacker may be able to read unauthorized files, such as `../config/prod.secrets.exs`, and make unauthorized changes to the filesystem. \n\n**How To Verify**\nIs user input being sent to the `File` function? If it is, this is a true positive. \n\n**How To Fix**\nDo not pass user input to `File` functions. The input should be system generated, for example: \n\n\n`%Plug.Upload{filename: filename, path: path} = upload`\n\n\nWhen `upload` is set by the user, it is not safe to pass the `filename` variable. The `path` variable is generated by plug, for example:\n\n\n`/var/folders/0m/d5lzvxvs181cl_f5m1x3wrx40000gn/T/plug-1681/multipart-1681411044-723629749623759-3`\n\n\nand is safe to pass as a variable. "},"id":"SBLW019","name":"Traversal.FileModule","properties":{"security-severity":"8.7"},"shortDescription":{"text":"Directory Traversal in `File` function"}},{"fullDescription":{"text":"Directory Traversal in `send_download`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. If user input is passed to `send_download`, an attacker may be able to read unauthorized files, such as `../config/prod.secrets.exs`, and make unauthorized changes to the filesystem. \n\n**How To Verify**\nConsider the example function in a Phoenix controller:\n\n\n```elixir\ndef user_pfp(conn, %{\"file_name\" => file_name}) do\n  send_download(conn, {:file, file_name})\nend\n```\n\n\nWhen `file_name` is controlled by the user, this is a true positive. If user input is being passed to `send_download`, this is a true positive.\n\n**How To Fix**\nDo not pass user input to `send_download`. Inputs to `send_download` should be pre-defined in the source code, not created dynamically by user input. \n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a high severity finding. If user input is passed to `send_download`, an attacker may be able to read unauthorized files, such as `../config/prod.secrets.exs`, and make unauthorized changes to the filesystem. \n\n**How To Verify**\nConsider the example function in a Phoenix controller:\n\n\n```elixir\ndef user_pfp(conn, %{\"file_name\" => file_name}) do\n  send_download(conn, {:file, file_name})\nend\n```\n\n\nWhen `file_name` is controlled by the user, this is a true positive. If user input is being passed to `send_download`, this is a true positive.\n\n**How To Fix**\nDo not pass user input to `send_download`. Inputs to `send_download` should be pre-defined in the source code, not created dynamically by user input. \n"},"id":"SBLW020","name":"Traversal.SendDownload","properties":{"security-severity":"8.7"},"shortDescription":{"text":"Directory Traversal in `send_download`"}},{"fullDescription":{"text":"Code Execution in EEx template eval"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. Calling the EEx functions `eval_string` and `eval_file` on external user input may allow an attacker to take over your web server. \n\n**How To Verify**\n\nIs user input being passed to the function that Sobelow flagged? For example:\n\n\n```\n> user_input = \"<%= 2 + 3 %>\"\n\"<%= 2 + 3 %>\"\n> EEx.eval_string(user_input)      \n\"5\"\n```\n\n\nIf the function is receiving user input, this is a true positive. \n\n**How To Fix**\n\nDo not allow user input to reach the `EEx` functions `eval_string` and `eval_file`. Input to these functions should never come from the network. \n\nhttps://hexdocs.pm/eex/1.14/EEx.html\n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. Calling the EEx functions `eval_string` and `eval_file` on external user input may allow an attacker to take over your web server. \n\n**How To Verify**\n\nIs user input being passed to the function that Sobelow flagged? For example:\n\n\n```\n> user_input = \"<%= 2 + 3 %>\"\n\"<%= 2 + 3 %>\"\n> EEx.eval_string(user_input)      \n\"5\"\n```\n\n\nIf the function is receiving user input, this is a true positive. \n\n**How To Fix**\n\nDo not allow user input to reach the `EEx` functions `eval_string` and `eval_file`. Input to these functions should never come from the network. \n\nhttps://hexdocs.pm/eex/1.14/EEx.html\n"},"id":"SBLW016","name":"RCE.EEx","properties":{"security-severity":"9.7"},"shortDescription":{"text":"Code Execution in EEx template eval"}},{"fullDescription":{"text":"Code execution in eval function"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. Calling the `Code` functions `eval_string`, `eval_file`, or `eval_quoted` on external user input may allow an attacker to take over your web server. \n\n**How To Verify**\n\nIs user input being passed to the function that Sobelow flagged? For example: \n\n\n`Code.eval_string(user_input)`\n\n\nIf the function is receiving user input, this is a true positive. \n\n**How To Fix**\n\nDo not allow user input to reach the `Code` functions `eval_string`, `eval_file`, or `eval_quoted`. Input to these functions should never come from the network. \n\n\nhttps://hexdocs.pm/elixir/Code.html\n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. Calling the `Code` functions `eval_string`, `eval_file`, or `eval_quoted` on external user input may allow an attacker to take over your web server. \n\n**How To Verify**\n\nIs user input being passed to the function that Sobelow flagged? For example: \n\n\n`Code.eval_string(user_input)`\n\n\nIf the function is receiving user input, this is a true positive. \n\n**How To Fix**\n\nDo not allow user input to reach the `Code` functions `eval_string`, `eval_file`, or `eval_quoted`. Input to these functions should never come from the network. \n\n\nhttps://hexdocs.pm/elixir/Code.html\n"},"id":"SBLW015","name":"RCE.CodeModule","properties":{"security-severity":"9.7"},"shortDescription":{"text":"Code execution in eval function"}},{"fullDescription":{"text":"Unsafe `binary_to_term`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. Unsafe usage of `binary_to_term` can lead to a remote code execution vulnerability, which allows an attacker to take over your web server. \n\n**How To Verify**\nIs user input being passed to `binary_to_term`? For example:\n\n\n`:erlang.binary_to_term(user_input, [:safe])`\n\n\nThe `[:safe]` option is misleading, this function is vulnerable. If user input is being passed to `binary_to_term`, this is a true positive. See [Elixir/Phoenix Security: Remote Code Execution and Serialisation](https://paraxial.io/blog/elixir-rce) for more details. \n\n**How To Fix**\nUse `Plug.Crypto.non_executable_binary_to_term` instead. \n\n\nhttps://hexdocs.pm/plug_crypto/Plug.Crypto.html#non_executable_binary_to_term/2\n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. Unsafe usage of `binary_to_term` can lead to a remote code execution vulnerability, which allows an attacker to take over your web server. \n\n**How To Verify**\nIs user input being passed to `binary_to_term`? For example:\n\n\n`:erlang.binary_to_term(user_input, [:safe])`\n\n\nThe `[:safe]` option is misleading, this function is vulnerable. If user input is being passed to `binary_to_term`, this is a true positive. See [Elixir/Phoenix Security: Remote Code Execution and Serialisation](https://paraxial.io/blog/elixir-rce) for more details. \n\n**How To Fix**\nUse `Plug.Crypto.non_executable_binary_to_term` instead. \n\n\nhttps://hexdocs.pm/plug_crypto/Plug.Crypto.html#non_executable_binary_to_term/2\n"},"id":"SBLW014","name":"Misc.BinToTerm","properties":{"security-severity":"9.7"},"shortDescription":{"text":"Unsafe `binary_to_term`"}},{"fullDescription":{"text":"Missing CSRF Protections"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a medium severity finding. An attacker can create a malicious web page, and when a victim visits the web page, the attacker can force the victim's browser to perform an action in the web application. \n\n**How To Verify**\nThe root cause of this finding is a pipeline in your application's router file that fetches a session, but does not implement the `:protect_from_forgery` plug. Locate an HTML form, which makes a POST request, matching this pipeline. For example:\n\n```\n<form action=\"/posts\" method=\"post\">\n\n  <label for=\"post_title\">Title</label>\n  <input id=\"post_title\" name=\"post[title]\" type=\"text\">\n\n  <label for=\"post_body\">Body</label>\n  <textarea id=\"post_body\" name=\"post[body]\">\n  </textarea>\n\n  <div>\n    <button type=\"submit\">Save</button>\n  </div>\n</form>\n```\n\nThis form is vulnerable to CSRF because there is no CSRF token. Note that even if there is a CSRF token in the form, such as:\n\n```\n<input name=\"_csrf_token\" type=\"hidden\"\n value=\"C3ceAlcYFxhHPC8WAnUfNCMsARUGJgZ5m9Rd5ZDG-HDVDDTMn_gHg_e8\">\n```\n\nThe form may still be vulnerable if the plug `:protect_from_forgery` is not present. \n\nTo verify if the vulnerability is present, create a new file, `poc.html`, and enter the following: \n\n```\n<form action=\"http://localhost:4000/posts\" method=\"post\" name=\"csrf_attack\">\n\n  <input id=\"post_title\" name=\"post[title]\" value=\"Hacked\">\n\n  <input id=\"post_body\" name=\"post[body]\" value=\"Hacked by Dogs\">\n\n  <div>\n    <button type=\"submit\">Save</button>\n  </div>\n</form>\n```\n\nEnsure you are logged into the vulnerable application with a valid session, then open `poc.html` in the same web browser. If submitting this form performs the action in your account, in this case creating a post, the vulnerability exists. \n\n\n**How To Fix**\nEnsure you are using the `:protect_from_forgery` plug in pipelines that fetch a session. Even if the HTML form has a CSRF token, the vulnerability still exists if the backend application is not checking if the token is valid. `:protect_from_forgery` performs the check. \n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a medium severity finding. An attacker can create a malicious web page, and when a victim visits the web page, the attacker can force the victim's browser to perform an action in the web application. \n\n**How To Verify**\nThe root cause of this finding is a pipeline in your application's router file that fetches a session, but does not implement the `:protect_from_forgery` plug. Locate an HTML form, which makes a POST request, matching this pipeline. For example:\n\n```\n<form action=\"/posts\" method=\"post\">\n\n  <label for=\"post_title\">Title</label>\n  <input id=\"post_title\" name=\"post[title]\" type=\"text\">\n\n  <label for=\"post_body\">Body</label>\n  <textarea id=\"post_body\" name=\"post[body]\">\n  </textarea>\n\n  <div>\n    <button type=\"submit\">Save</button>\n  </div>\n</form>\n```\n\nThis form is vulnerable to CSRF because there is no CSRF token. Note that even if there is a CSRF token in the form, such as:\n\n```\n<input name=\"_csrf_token\" type=\"hidden\"\n value=\"C3ceAlcYFxhHPC8WAnUfNCMsARUGJgZ5m9Rd5ZDG-HDVDDTMn_gHg_e8\">\n```\n\nThe form may still be vulnerable if the plug `:protect_from_forgery` is not present. \n\nTo verify if the vulnerability is present, create a new file, `poc.html`, and enter the following: \n\n```\n<form action=\"http://localhost:4000/posts\" method=\"post\" name=\"csrf_attack\">\n\n  <input id=\"post_title\" name=\"post[title]\" value=\"Hacked\">\n\n  <input id=\"post_body\" name=\"post[body]\" value=\"Hacked by Dogs\">\n\n  <div>\n    <button type=\"submit\">Save</button>\n  </div>\n</form>\n```\n\nEnsure you are logged into the vulnerable application with a valid session, then open `poc.html` in the same web browser. If submitting this form performs the action in your account, in this case creating a post, the vulnerability exists. \n\n\n**How To Fix**\nEnsure you are using the `:protect_from_forgery` plug in pipelines that fetch a session. Even if the HTML form has a CSRF token, the vulnerability still exists if the backend application is not checking if the token is valid. `:protect_from_forgery` performs the check. \n"},"id":"SBLW005","name":"Config.CSRF","properties":{"security-severity":"6.7"},"shortDescription":{"text":"Missing CSRF Protections"}},{"fullDescription":{"text":"CSRF via Action Reuse"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a medium severity finding. An attacker can create a malicious web page, and when a victim visits the web page, the attacker can force the victim's browser to perform an action in the web application. The attacker cannot leak data from the victim through CSRF, it is a write-only attack. For example, a banking application vulnerable to CSRF where an attacker can force the victim to make a POST request, transferring money to the attacker. \n\n**How To Verify**\nIn your Phoenix router, there should be two routes that use the same action, for example:\n\n```\n  get \"/users/settings/edit_bio\", UserSettingsController, :edit_bio\n  post \"/users/settings/edit_bio\", UserSettingsController, :edit_bio\n```\n\nNote that both the GET and POST request are sent to the same function, `:edit_bio`. A user can update their bio with a POST request, where the POST body contains:\n\n`user[bio]=This+is+some+info+about+my+profile+page`\n\nThis is safe, state changing actions should use POST, because they can be protected from CSRF. This same state changing action can also be triggered via a GET request, which is unsafe, because GET requests are always vulnerable to CSRF. For example, if the victim visits the route:\n\nhttp://potionshop.url/users/settings/edit_bio?user%5Bbio%5D=Hacked+LOL\n\nTheir bio will be updated. The POST request to `/users/settings/edit_bio` is not vulnerable to CSRF. Rather, it's the GET request to `/users/settings/edit_bio`, which contains the same parameters as the POST request in the URL, which is the source of this vulnerability. If you can issue a GET request that triggers the same functionality as the POST request, this finding is a true positive. \nAdditional details - https://paraxial.io/blog/action-reuse-csrf \n\n**How To Fix**\nDo not point multiple routes to the same controller function. In the GET request route, do not allow state changing actions for authenticated users associated with a POST request. Examples of state changing actions are transferring money in a banking application, adding an admin user to a business management portal, or creating a new post on a social media website. \n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a medium severity finding. An attacker can create a malicious web page, and when a victim visits the web page, the attacker can force the victim's browser to perform an action in the web application. The attacker cannot leak data from the victim through CSRF, it is a write-only attack. For example, a banking application vulnerable to CSRF where an attacker can force the victim to make a POST request, transferring money to the attacker. \n\n**How To Verify**\nIn your Phoenix router, there should be two routes that use the same action, for example:\n\n```\n  get \"/users/settings/edit_bio\", UserSettingsController, :edit_bio\n  post \"/users/settings/edit_bio\", UserSettingsController, :edit_bio\n```\n\nNote that both the GET and POST request are sent to the same function, `:edit_bio`. A user can update their bio with a POST request, where the POST body contains:\n\n`user[bio]=This+is+some+info+about+my+profile+page`\n\nThis is safe, state changing actions should use POST, because they can be protected from CSRF. This same state changing action can also be triggered via a GET request, which is unsafe, because GET requests are always vulnerable to CSRF. For example, if the victim visits the route:\n\nhttp://potionshop.url/users/settings/edit_bio?user%5Bbio%5D=Hacked+LOL\n\nTheir bio will be updated. The POST request to `/users/settings/edit_bio` is not vulnerable to CSRF. Rather, it's the GET request to `/users/settings/edit_bio`, which contains the same parameters as the POST request in the URL, which is the source of this vulnerability. If you can issue a GET request that triggers the same functionality as the POST request, this finding is a true positive. \nAdditional details - https://paraxial.io/blog/action-reuse-csrf \n\n**How To Fix**\nDo not point multiple routes to the same controller function. In the GET request route, do not allow state changing actions for authenticated users associated with a POST request. Examples of state changing actions are transferring money in a banking application, adding an admin user to a business management portal, or creating a new post on a social media website. \n"},"id":"SBLW004","name":"Config.CSRFRoute","properties":{"security-severity":"6.7"},"shortDescription":{"text":"CSRF via Action Reuse"}},{"fullDescription":{"text":"Missing Secure Browser Headers"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a low severity finding. Missing secure browser headers is not a vulnerability. Having these headers is considered a best practice. By default, Phoenix HTTP responses contain a number of secure HTTP headers that attempt to mitigate XSS, click-jacking, and content-sniffing attacks. Missing Secure HTTP Headers is flagged by `sobelow` when a pipeline accepts \"html\" requests, but does not implement the `:put_secure_browser_headers` plug.\n\n**How To Verify**\n\nMost Phoenix applications set these headers by default. This finding is triggered when a router pipeline accepts `html` requests, but does not implement the `:put_secure_browser_headers` plug. Check the response of a request in this pipeline for the headers:\n\n\n```\nreferrer-policy\nx-frame-options\nx-content-type-options\nx-download-options \nx-permitted-cross-domain-policies \n```\n\n\nhttps://hexdocs.pm/phoenix/Phoenix.Controller.html#put_secure_browser_headers/2\n\n**How To Fix**\n\nAdd the plug `:put_secure_browser_headers` to the pipeline. ","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a low severity finding. Missing secure browser headers is not a vulnerability. Having these headers is considered a best practice. By default, Phoenix HTTP responses contain a number of secure HTTP headers that attempt to mitigate XSS, click-jacking, and content-sniffing attacks. Missing Secure HTTP Headers is flagged by `sobelow` when a pipeline accepts \"html\" requests, but does not implement the `:put_secure_browser_headers` plug.\n\n**How To Verify**\n\nMost Phoenix applications set these headers by default. This finding is triggered when a router pipeline accepts `html` requests, but does not implement the `:put_secure_browser_headers` plug. Check the response of a request in this pipeline for the headers:\n\n\n```\nreferrer-policy\nx-frame-options\nx-content-type-options\nx-download-options \nx-permitted-cross-domain-policies \n```\n\n\nhttps://hexdocs.pm/phoenix/Phoenix.Controller.html#put_secure_browser_headers/2\n\n**How To Fix**\n\nAdd the plug `:put_secure_browser_headers` to the pipeline. "},"id":"SBLW007","name":"Config.Headers","properties":{"security-severity":"2.7"},"shortDescription":{"text":"Missing Secure Browser Headers"}},{"fullDescription":{"text":"Missing Content-Security-Policy"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a low severity finding. Missing CSP is not a vulnerability, it is a layer of defense to stop XSS and data injection attacks. An attacker must exploit a XSS vulnerability that already exists for CSP to be relevant. \n\n**How To Verify**\nCheck the HTTP response from your web server for the `content-security-policy` header. \n\n**How To Fix**\nUse `plug :put_secure_browser_headers` in your pipeline. Documentation on the `put_secure_browser_headers` plug function can be found here: https://hexdocs.pm/phoenix/Phoenix.Controller.html#put_secure_browser_headers/2\n\nExample policy:\n\n`plug :put_secure_browser_headers, %{\"content-security-policy\" => \"default-src 'self'\"}`\n\n*Warning: Note that adding a restrictive CSP header will improve security, but may break your application's JavaScript. Read https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP for more details.*\n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a low severity finding. Missing CSP is not a vulnerability, it is a layer of defense to stop XSS and data injection attacks. An attacker must exploit a XSS vulnerability that already exists for CSP to be relevant. \n\n**How To Verify**\nCheck the HTTP response from your web server for the `content-security-policy` header. \n\n**How To Fix**\nUse `plug :put_secure_browser_headers` in your pipeline. Documentation on the `put_secure_browser_headers` plug function can be found here: https://hexdocs.pm/phoenix/Phoenix.Controller.html#put_secure_browser_headers/2\n\nExample policy:\n\n`plug :put_secure_browser_headers, %{\"content-security-policy\" => \"default-src 'self'\"}`\n\n*Warning: Note that adding a restrictive CSP header will improve security, but may break your application's JavaScript. Read https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP for more details.*\n"},"id":"SBLW003","name":"Config.CSP","properties":{"security-severity":"2.7"},"shortDescription":{"text":"Missing Content-Security-Policy"}},{"fullDescription":{"text":"Hardcoded Secret"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity finding. Hard coding secrets in source code is not recommended.\n\n**How To Verify**\n\nSobelow checks for configuration variables such as `secret_key_base`, `password`, and `secret` with a matching string. Read the finding, and determine if the value stored in source code is a true secret. \n\n**How To Fix**\n\nThe best practice for secrets is to store them as environment variables. \n","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity finding. Hard coding secrets in source code is not recommended.\n\n**How To Verify**\n\nSobelow checks for configuration variables such as `secret_key_base`, `password`, and `secret` with a matching string. Read the finding, and determine if the value stored in source code is a true secret. \n\n**How To Fix**\n\nThe best practice for secrets is to store them as environment variables. \n"},"id":"SBLW010","name":"Config.Secrets","properties":{"security-severity":"5.7"},"shortDescription":{"text":"Hardcoded Secret"}},{"fullDescription":{"text":"HTTPS Not Enabled"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a high severity finding. Using HTTPS is a requirement if your application handles user data. \n\n**How To Verify**\n\nThis finding is often a false positive, because HTTPS configuration may be set at a different layer in the application stack. For example, your web server may be configured to force HTTPS. Test if your application serves traffic from `http://` and `https://`. If you are able to send data to your server over `http://`, this is a true positive. \n\n**How To Fix**\n\nConfigure your Phoenix application to use HTTPS - https://hexdocs.pm/phoenix/using_ssl.html#content\n","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a high severity finding. Using HTTPS is a requirement if your application handles user data. \n\n**How To Verify**\n\nThis finding is often a false positive, because HTTPS configuration may be set at a different layer in the application stack. For example, your web server may be configured to force HTTPS. Test if your application serves traffic from `http://` and `https://`. If you are able to send data to your server over `http://`, this is a true positive. \n\n**How To Fix**\n\nConfigure your Phoenix application to use HTTPS - https://hexdocs.pm/phoenix/using_ssl.html#content\n"},"id":"SBLW009","name":"Config.HTTPS","properties":{"security-severity":"8.7"},"shortDescription":{"text":"HTTPS Not Enabled"}},{"fullDescription":{"text":"HSTS Not Enabled"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a low severity finding. The HSTS header is used to defend against man-in-the-middle attacks by preventing unencrypted connections.\n\n**How To Verify**\n\nCheck your config file for:\n\n\n```elixir\nconfig :havana, HavanaWeb.Endpoint,\n  force_ssl: [hsts: true]\n```\n\n\nRemember that Sobelow is limited to your Phoenix application code. Your deployed application may be using HSTS correctly, due to a server level configuration. Use https://www.ssllabs.com/ssltest/ to verify your deployed settings. \n\nhttps://hexdocs.pm/phoenix/using_ssl.html#hsts\n\nhttps://hexdocs.pm/plug/Plug.SSL.html\n\n**How To Fix**\n\nSet the following config:\n\n```\nconfig :havana, HavanaWeb.Endpoint,\n  force_ssl: [hsts: true]\n```\n\nReplace \"Havana\" with your application name. Use https://www.ssllabs.com/ssltest/ to verify your deployed settings. \n","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a low severity finding. The HSTS header is used to defend against man-in-the-middle attacks by preventing unencrypted connections.\n\n**How To Verify**\n\nCheck your config file for:\n\n\n```elixir\nconfig :havana, HavanaWeb.Endpoint,\n  force_ssl: [hsts: true]\n```\n\n\nRemember that Sobelow is limited to your Phoenix application code. Your deployed application may be using HSTS correctly, due to a server level configuration. Use https://www.ssllabs.com/ssltest/ to verify your deployed settings. \n\nhttps://hexdocs.pm/phoenix/using_ssl.html#hsts\n\nhttps://hexdocs.pm/plug/Plug.SSL.html\n\n**How To Fix**\n\nSet the following config:\n\n```\nconfig :havana, HavanaWeb.Endpoint,\n  force_ssl: [hsts: true]\n```\n\nReplace \"Havana\" with your application name. Use https://www.ssllabs.com/ssltest/ to verify your deployed settings. \n"},"id":"SBLW008","name":"Config.HSTS","properties":{"security-severity":"2.7"},"shortDescription":{"text":"HSTS Not Enabled"}},{"fullDescription":{"text":"Cross-Site Websocket Hijacking"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity vulnerability. Exploiting CSWH requires an attacker to setup a malicious website, then get the victim to browse to the site, while also logged into their current session. CSWH does allow the attacker to take over the victim's account, the requirement for user interaction reduces the severity. \n\nDetails on CSWH - https://christian-schneider.net/CrossSiteWebSocketHijacking.html\n\n**How To Verify**\nExample of a bad endpoint:\n\n\n```\ndefmodule PhoenixWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :phoenix\n\n  socket(\"/socket\", PhoenixInternalsWeb.UserSocket,\n    websocket: [check_origin: false],\n    longpoll: false\n  )\nend\n```\n\nExample of a good endpoint:\n\n\n```\ndefmodule PhoenixWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :phoenix\n\n  socket(\"/socket\", PhoenixInternalsWeb.UserSocket,\n    websocket: true,\n    longpoll: false\n  )\nend\n```\n\n**How To Fix**\nEnsure `:check_origin` is enabled. It defaults to true.\n\n\nPhoenix Docs - https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#socket/3\n","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity vulnerability. Exploiting CSWH requires an attacker to setup a malicious website, then get the victim to browse to the site, while also logged into their current session. CSWH does allow the attacker to take over the victim's account, the requirement for user interaction reduces the severity. \n\nDetails on CSWH - https://christian-schneider.net/CrossSiteWebSocketHijacking.html\n\n**How To Verify**\nExample of a bad endpoint:\n\n\n```\ndefmodule PhoenixWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :phoenix\n\n  socket(\"/socket\", PhoenixInternalsWeb.UserSocket,\n    websocket: [check_origin: false],\n    longpoll: false\n  )\nend\n```\n\nExample of a good endpoint:\n\n\n```\ndefmodule PhoenixWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :phoenix\n\n  socket(\"/socket\", PhoenixInternalsWeb.UserSocket,\n    websocket: true,\n    longpoll: false\n  )\nend\n```\n\n**How To Fix**\nEnsure `:check_origin` is enabled. It defaults to true.\n\n\nPhoenix Docs - https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#socket/3\n"},"id":"SBLW006","name":"Config.CSWH","properties":{"security-severity":"4.7"},"shortDescription":{"text":"Cross-Site Websocket Hijacking"}},{"fullDescription":{"text":"Command Injection in `System.cmd`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. An attacker can exploit this vulnerability to take over your entire web server, stealing your database, and causing a major data breach incident. \n\n**How To Verify**\nThe danger of command injection is that an attacker can send a malicious string which is passed to a call to `System.cmd`. For example:\n\n\n```\niex(1)> user_input = 'ls'\niex(2)> System.cmd(user_input, [])\n{\"CHANGELOG.md\\nREADME.md\\nlib\\nmix.exs\\nmix.lock\\ntest\\n\", 0}\n```\n\n\nIf an attacker can get malicious input into `System.cmd`, you have verified this finding as a true positive. \n\n**How To Fix**\nEnsure user input can never reach this function. \n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. An attacker can exploit this vulnerability to take over your entire web server, stealing your database, and causing a major data breach incident. \n\n**How To Verify**\nThe danger of command injection is that an attacker can send a malicious string which is passed to a call to `System.cmd`. For example:\n\n\n```\niex(1)> user_input = 'ls'\niex(2)> System.cmd(user_input, [])\n{\"CHANGELOG.md\\nREADME.md\\nlib\\nmix.exs\\nmix.lock\\ntest\\n\", 0}\n```\n\n\nIf an attacker can get malicious input into `System.cmd`, you have verified this finding as a true positive. \n\n**How To Fix**\nEnsure user input can never reach this function. \n"},"id":"SBLW002","name":"CI.System","properties":{"security-severity":"9.7"},"shortDescription":{"text":"Command Injection in `System.cmd`"}},{"fullDescription":{"text":"Command Injection in `:os.cmd`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. An attacker can exploit this vulnerability to take over your entire web server, stealing your database, and causing a major data breach incident. \n\n**How To Verify**\nThe danger of command injection is that an attacker can send a malicious string which is passed to a call to `:os.cmd`. This function requires a charlist, for example:\n\n```\niex(1)> user_input = 'ls'\niex(2)> :os.cmd(user_input)\n'CHANGELOG.md\\nLICENSE\\nREADME.md\\nlib\\nmix.exs\\nmix.lock\\ntest\\n'\n```\n\nIf an attacker can get malicious input into `:os.cmd`, you have verified this finding as a true positive. \n\n**How To Fix**\nEnsure user input can never reach this function. \n","text":"Paraxial.io Analysis:\n\n**Severity**\nThis is a critical severity finding. An attacker can exploit this vulnerability to take over your entire web server, stealing your database, and causing a major data breach incident. \n\n**How To Verify**\nThe danger of command injection is that an attacker can send a malicious string which is passed to a call to `:os.cmd`. This function requires a charlist, for example:\n\n```\niex(1)> user_input = 'ls'\niex(2)> :os.cmd(user_input)\n'CHANGELOG.md\\nLICENSE\\nREADME.md\\nlib\\nmix.exs\\nmix.lock\\ntest\\n'\n```\n\nIf an attacker can get malicious input into `:os.cmd`, you have verified this finding as a true positive. \n\n**How To Fix**\nEnsure user input can never reach this function. \n"},"id":"SBLW001","name":"CI.OS","properties":{"security-severity":"9.7"},"shortDescription":{"text":"Command Injection in `:os.cmd`"}},{"fullDescription":{"text":"Unsafe `String.to_atom`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity finding. It does not allow the attacker to access private data, or performed unauthorized actions. Atom DoS allows an attacker to trigger a crash of the Erlang virtual machine. There are two possible outcomes:\n\n#### 1. The application crashes and restarts. There will be some downtime during the restart, but overall the impact will be low.\n\n#### 2. The application crashes and remains down. This is a higher severity incident.\n\nThe behavior of your application depends on the deployment environment. Instructions for testing your environment - https://paraxial.io/blog/atom-dos-impact \n\n**How To Verify**\n\nIs user input being passed to `String.to_atom`? If it is, this is a true positive. \n\n**How To Fix**\n\nUse `String.to_existing_atom` instead.\n\n\nhttps://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity finding. It does not allow the attacker to access private data, or performed unauthorized actions. Atom DoS allows an attacker to trigger a crash of the Erlang virtual machine. There are two possible outcomes:\n\n#### 1. The application crashes and restarts. There will be some downtime during the restart, but overall the impact will be low.\n\n#### 2. The application crashes and remains down. This is a higher severity incident.\n\nThe behavior of your application depends on the deployment environment. Instructions for testing your environment - https://paraxial.io/blog/atom-dos-impact \n\n**How To Verify**\n\nIs user input being passed to `String.to_atom`? If it is, this is a true positive. \n\n**How To Fix**\n\nUse `String.to_existing_atom` instead.\n\n\nhttps://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion"},"id":"SBLW013","name":"DOS.StringToAtom","properties":{"security-severity":"6.7"},"shortDescription":{"text":"Unsafe `String.to_atom`"}},{"fullDescription":{"text":"Unsafe `List.to_atom`"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity finding. It does not allow the attacker to access private data, or performed unauthorized actions. Atom DoS allows an attacker to trigger a crash of the Erlang virtual machine. There are two possible outcomes:\n\n#### 1. The application crashes and restarts. There will be some downtime during the restart, but overall the impact will be low.\n\n#### 2. The application crashes and remains down. This is a higher severity incident.\n\nThe behavior of your application depends on the deployment environment. Instructions for testing your environment - https://paraxial.io/blog/atom-dos-impact \n\n**How To Verify**\n\nIs user input being passed to `List.to_atom`? If it is, this is a true positive. \n\n**How To Fix**\n\nUse `List.to_existing_atom` instead.\n\n\nhttps://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity finding. It does not allow the attacker to access private data, or performed unauthorized actions. Atom DoS allows an attacker to trigger a crash of the Erlang virtual machine. There are two possible outcomes:\n\n#### 1. The application crashes and restarts. There will be some downtime during the restart, but overall the impact will be low.\n\n#### 2. The application crashes and remains down. This is a higher severity incident.\n\nThe behavior of your application depends on the deployment environment. Instructions for testing your environment - https://paraxial.io/blog/atom-dos-impact \n\n**How To Verify**\n\nIs user input being passed to `List.to_atom`? If it is, this is a true positive. \n\n**How To Fix**\n\nUse `List.to_existing_atom` instead.\n\n\nhttps://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion"},"id":"SBLW012","name":"DOS.ListToAtom","properties":{"security-severity":"6.7"},"shortDescription":{"text":"Unsafe `List.to_atom`"}},{"fullDescription":{"text":"Unsafe atom interpolation"},"help":{"markdown":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity finding. It does not allow the attacker to access private data, or performed unauthorized actions. Atom DoS allows an attacker to trigger a crash of the Erlang virtual machine. There are two possible outcomes:\n\n#### 1. The application crashes and restarts. There will be some downtime during the restart, but overall the impact will be low.\n\n#### 2. The application crashes and remains down. This is a higher severity incident.\n\nThe behavior of your application depends on the deployment environment. Instructions for testing your environment - https://paraxial.io/blog/atom-dos-impact \n\n**How To Verify**\n\nIs user input being passed to `:new_atom_#{a}` or `:erlang.binary_to_atom`? If it is, this is a true positive. \n\n**How To Fix**\n\nUse `String.to_existing_atom`. Do not create new atoms at runtime. Restructure your code so that atoms do not need to be created from user input. \n\n\nhttps://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion\n","text":"Paraxial.io Analysis:\n\n**Severity**\n\nThis is a medium severity finding. It does not allow the attacker to access private data, or performed unauthorized actions. Atom DoS allows an attacker to trigger a crash of the Erlang virtual machine. There are two possible outcomes:\n\n#### 1. The application crashes and restarts. There will be some downtime during the restart, but overall the impact will be low.\n\n#### 2. The application crashes and remains down. This is a higher severity incident.\n\nThe behavior of your application depends on the deployment environment. Instructions for testing your environment - https://paraxial.io/blog/atom-dos-impact \n\n**How To Verify**\n\nIs user input being passed to `:new_atom_#{a}` or `:erlang.binary_to_atom`? If it is, this is a true positive. \n\n**How To Fix**\n\nUse `String.to_existing_atom`. Do not create new atoms at runtime. Restructure your code so that atoms do not need to be created from user input. \n\n\nhttps://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion\n"},"id":"SBLW011","name":"DOS.BinToAtom","properties":{"security-severity":"6.7"},"shortDescription":{"text":"Unsafe atom interpolation"}},{"fullDescription":{"text":"Known Vulnerable Dependency - Update Plug"},"help":{"markdown":"# Plug Version Vulnerable to Null Byte Injection\n\nFor more information visit: https://github.com/advisories/GHSA-2q6v-32mr-8p8x\n\nNull Byte Injection checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.PlugNull ","text":"# Plug Version Vulnerable to Null Byte Injection\n\nFor more information visit: https://github.com/advisories/GHSA-2q6v-32mr-8p8x\n\nNull Byte Injection checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.PlugNull "},"id":"SBLW026","name":"Vuln.PlugNull","shortDescription":{"text":"Known Vulnerable Dependency - Update Plug"}},{"fullDescription":{"text":"Known Vulnerable Dependency - Update Plug"},"help":{"markdown":"# Plug Version Vulnerable to Arbitrary Code Execution in Cookie Serialization\n\nFor more information visit: https://github.com/advisories/GHSA-5v4m-c73v-c7gq\n\nCookie RCE checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.CookieRCE ","text":"# Plug Version Vulnerable to Arbitrary Code Execution in Cookie Serialization\n\nFor more information visit: https://github.com/advisories/GHSA-5v4m-c73v-c7gq\n\nCookie RCE checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.CookieRCE "},"id":"SBLW023","name":"Vuln.Plug","shortDescription":{"text":"Known Vulnerable Dependency - Update Plug"}},{"fullDescription":{"text":"Known Vulnerable Dependency - Update Plug"},"help":{"markdown":"# Plug Version Vulnerable to Header Injection\n\nFor more information visit: https://github.com/advisories/GHSA-9h73-w7ch-rh73\n\nHeader Injection checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.HeaderInject ","text":"# Plug Version Vulnerable to Header Injection\n\nFor more information visit: https://github.com/advisories/GHSA-9h73-w7ch-rh73\n\nHeader Injection checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.HeaderInject "},"id":"SBLW025","name":"Vuln.HeaderInject","shortDescription":{"text":"Known Vulnerable Dependency - Update Plug"}},{"fullDescription":{"text":"Known Vulnerable Dependency - Update Phoenix"},"help":{"markdown":"# Phoenix Version Vulnerable to Arbitrary URL Redirection\n\nFor more information visit: https://github.com/advisories/GHSA-cmfh-8f8r-fj96\n\nURL Redirection checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.Redirect ","text":"# Phoenix Version Vulnerable to Arbitrary URL Redirection\n\nFor more information visit: https://github.com/advisories/GHSA-cmfh-8f8r-fj96\n\nURL Redirection checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.Redirect "},"id":"SBLW027","name":"Vuln.Redirect","shortDescription":{"text":"Known Vulnerable Dependency - Update Phoenix"}},{"fullDescription":{"text":"Known Vulnerable Dependency - Update Coherence"},"help":{"markdown":"# Coherence Version Vulnerable to Privilege Escalation\n\nFor more information visit: https://github.com/advisories/GHSA-mrq8-53r4-3j5m\n\nCoherence checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.Coherence ","text":"# Coherence Version Vulnerable to Privilege Escalation\n\nFor more information visit: https://github.com/advisories/GHSA-mrq8-53r4-3j5m\n\nCoherence checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.Coherence "},"id":"SBLW022","name":"Vuln.Coherence","shortDescription":{"text":"Known Vulnerable Dependency - Update Coherence"}},{"fullDescription":{"text":"Known Vulnerable Dependency - Update Ecto"},"help":{"markdown":"# Ecto Version Lacks Protection Mechanism\n\nFor more information visit: https://github.com/advisories/GHSA-2xxx-fhc8-9qvq\n\nEcto checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.Ecto ","text":"# Ecto Version Lacks Protection Mechanism\n\nFor more information visit: https://github.com/advisories/GHSA-2xxx-fhc8-9qvq\n\nEcto checks can be ignored with the following command:\n\n    $ mix sobelow -i Vuln.Ecto "},"id":"SBLW024","name":"Vuln.Ecto","shortDescription":{"text":"Known Vulnerable Dependency - Update Ecto"}}],"semanticVersion":"0.13.0"}}}],"version":"2.1.0"}